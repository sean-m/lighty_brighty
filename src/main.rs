/* 
    lighty_brighty
    All the trappings of a modern laptop OS are here in Gnome and Plasma, why
    is automatic screen brightness adjustment only found in Gnome? Well DBus
    exists and those Gnome folks really love it. Ambient light sensor data that
    gnome-shell uses for automatic screen brightness is exposed by the wonderful
    iio-sensor-proxy service.

    Some simple code and Plasma's dbus inteface for screen brightness make it
    possible to have a screen brightness daemon that works without root privileges
    and only adjusts brightness when needed. This is not that service, this is
    a tribute.
*/

use zbus::{Connection, dbus_proxy, Result};
use futures_util::stream::StreamExt;


// generated by zbus-xmlgen, full reference in zensor_proxy_trait.rs
#[dbus_proxy(
    default_service = "net.hadess.SensorProxy",
    interface = "net.hadess.SensorProxy",
    default_path = "/net/hadess/SensorProxy",
)]
trait SensorProxy {
    /// ClaimAccelerometer method
    fn claim_accelerometer(&self) -> zbus::Result<()>;

    /// ClaimLight method
    fn claim_light(&self) -> zbus::Result<()>;

    /// ClaimProximity method
    fn claim_proximity(&self) -> zbus::Result<()>;

    /// ReleaseAccelerometer method
    fn release_accelerometer(&self) -> zbus::Result<()>;

    /// ReleaseLight method
    fn release_light(&self) -> zbus::Result<()>;

    /// ReleaseProximity method
    fn release_proximity(&self) -> zbus::Result<()>;

    /// AccelerometerOrientation property
    #[dbus_proxy(property)]
    fn accelerometer_orientation(&self) -> zbus::Result<String>;

    /// HasAccelerometer property
    #[dbus_proxy(property)]
    fn has_accelerometer(&self) -> zbus::Result<bool>;

    /// HasAmbientLight property
    #[dbus_proxy(property)]
    fn has_ambient_light(&self) -> zbus::Result<bool>;

    /// HasProximity property
    #[dbus_proxy(property)]
    fn has_proximity(&self) -> zbus::Result<bool>;

    /// LightLevel property
    #[dbus_proxy(property)]
    fn light_level(&self) -> zbus::Result<f64>;

    /// LightLevelUnit property
    #[dbus_proxy(property)]
    fn light_level_unit(&self) -> zbus::Result<String>;

    /// ProximityNear property
    #[dbus_proxy(property)]
    fn proximity_near(&self) -> zbus::Result<bool>;
}



// Although we use `async-std` here, you can use any async runtime of choice.
#[async_std::main]
async fn main() -> Result<()> {

    let sensor_service   = "net.hadess.SensorProxy";
    let sensor_interface = "net.hadess.SensorProxy";
    let sensor_path      = "/net/hadess/SensorProxy";


    let conn = Connection::system().await?;
    let proxy = SensorProxyProxy::new(&conn).await?;
    proxy.claim_light().await?;
    
    let props = zbus::fdo::PropertiesProxy::builder(&conn)
        .destination(sensor_service)?
        .path(sensor_path)?
        .build()
        .await?;

    let mut props_changed = props.receive_properties_changed().await?;


    futures_util::try_join!(
        async {
            while let Some(signal) = props_changed.next().await {
                let args = signal.args()?;

                for (name, value) in args.changed_properties().iter() {
                    //println!("{}.{} changed to `{:?}`", args.interface_name(), name, value);
                    println!("{} changed to `{:?}`", name, value);
                }
            }

            Ok::<(), zbus::Error>(())
        }
    )?;

   Ok(())
}
